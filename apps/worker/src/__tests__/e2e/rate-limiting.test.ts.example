/**
 * E2E Test: Provider Rate Limiting
 *
 * Example tests showing how to test different rate limit scenarios.
 * Rename to .test.ts to enable these tests.
 *
 * These tests demonstrate:
 * - Testing with AWS SES 14/sec limit
 * - Testing with increased limits (50/sec, 100/sec)
 * - Testing extremely slow providers (1/sec)
 * - Testing enterprise scale (500/sec)
 * - Verifying rate limits are respected
 */

import { describe, it, expect, beforeEach } from "vitest";
import { db } from "../../../test/db.js";
import {
  createBatch,
  waitFor,
  generateRecipients,
  setApiKey,
} from "../../../test/helpers.js";
import { createTestUser, createTestApiKey } from "../helpers/fixtures.js";
import {
  RateLimitScenarios,
  calculateTestTimeout,
  verifyRateLimit,
  logRateLimitResults,
} from "../../../test/rate-limit-helpers.js";
import { batches } from "@batchsender/db";
import { eq } from "drizzle-orm";

describe("E2E: Rate Limiting Scenarios", () => {
  let testUserId: string;

  beforeEach(async () => {
    const testUser = createTestUser();
    await db.insert(require("@batchsender/db").users).values(testUser);
    testUserId = testUser.id;

    const { apiKey, dbRecord } = createTestApiKey(testUserId);
    await db.insert(require("@batchsender/db").apiKeys).values(dbRecord);
    setApiKey(apiKey);
  });

  it(
    "should respect AWS SES default limits (14/sec)",
    async () => {
      // Configure for AWS SES default limits
      RateLimitScenarios.AWS_SES_DEFAULT();

      const BATCH_SIZE = 140; // 10 seconds at 14/sec
      const EXPECTED_RATE = 14;

      console.log(`\nTesting AWS SES default rate (14/sec) with ${BATCH_SIZE} emails`);

      const { id: batchId } = await createBatch({
        name: "Rate Limit Test - AWS SES Default",
        subject: "Test",
        fromEmail: "test@batchsender.local",
        recipients: generateRecipients(BATCH_SIZE),
        autoSend: true,
      });

      const start = Date.now();

      // Wait for completion
      await waitFor(
        async () => {
          const batch = await db.query.batches.findFirst({
            where: eq(batches.id, batchId),
          });
          return batch?.status === "completed" ? batch : null;
        },
        { timeout: calculateTestTimeout(BATCH_SIZE, EXPECTED_RATE) }
      );

      const elapsed = Date.now() - start;

      // Verify rate limit was respected
      const result = await verifyRateLimit(BATCH_SIZE, elapsed, EXPECTED_RATE);
      console.log(result.message);

      logRateLimitResults("AWS SES Default (14/sec)", BATCH_SIZE, elapsed, EXPECTED_RATE);

      expect(result.withinTolerance).toBe(true);
    },
    { timeout: 300000 } // 5 minutes
  );

  it(
    "should handle increased AWS SES limits (50/sec)",
    async () => {
      // Configure for increased AWS SES limits
      RateLimitScenarios.AWS_SES_INCREASED();

      const BATCH_SIZE = 500; // 10 seconds at 50/sec
      const EXPECTED_RATE = 50;

      console.log(`\nTesting increased AWS SES rate (50/sec) with ${BATCH_SIZE} emails`);

      const { id: batchId } = await createBatch({
        name: "Rate Limit Test - AWS SES Increased",
        subject: "Test",
        fromEmail: "test@batchsender.local",
        recipients: generateRecipients(BATCH_SIZE),
        autoSend: true,
      });

      const start = Date.now();

      await waitFor(
        async () => {
          const batch = await db.query.batches.findFirst({
            where: eq(batches.id, batchId),
          });
          return batch?.status === "completed" ? batch : null;
        },
        { timeout: calculateTestTimeout(BATCH_SIZE, EXPECTED_RATE) }
      );

      const elapsed = Date.now() - start;
      const result = await verifyRateLimit(BATCH_SIZE, elapsed, EXPECTED_RATE);

      logRateLimitResults("AWS SES Increased (50/sec)", BATCH_SIZE, elapsed, EXPECTED_RATE);

      expect(result.withinTolerance).toBe(true);
    },
    { timeout: 300000 }
  );

  it(
    "should handle high throughput (100/sec)",
    async () => {
      RateLimitScenarios.HIGH_THROUGHPUT();

      const BATCH_SIZE = 1000;
      const EXPECTED_RATE = 100;

      console.log(`\nTesting high throughput (100/sec) with ${BATCH_SIZE} emails`);

      const { id: batchId } = await createBatch({
        name: "Rate Limit Test - High Throughput",
        subject: "Test",
        fromEmail: "test@batchsender.local",
        recipients: generateRecipients(BATCH_SIZE),
        autoSend: true,
      });

      const start = Date.now();

      await waitFor(
        async () => {
          const batch = await db.query.batches.findFirst({
            where: eq(batches.id, batchId),
          });
          return batch?.status === "completed" ? batch : null;
        },
        { timeout: calculateTestTimeout(BATCH_SIZE, EXPECTED_RATE) }
      );

      const elapsed = Date.now() - start;
      const result = await verifyRateLimit(BATCH_SIZE, elapsed, EXPECTED_RATE);

      logRateLimitResults("High Throughput (100/sec)", BATCH_SIZE, elapsed, EXPECTED_RATE);

      expect(result.withinTolerance).toBe(true);
    },
    { timeout: 300000 }
  );

  it(
    "should handle enterprise scale (500/sec)",
    async () => {
      RateLimitScenarios.ENTERPRISE_SCALE();

      const BATCH_SIZE = 5000;
      const EXPECTED_RATE = 500;

      console.log(`\nTesting enterprise scale (500/sec) with ${BATCH_SIZE} emails`);

      const { id: batchId } = await createBatch({
        name: "Rate Limit Test - Enterprise Scale",
        subject: "Test",
        fromEmail: "test@batchsender.local",
        recipients: generateRecipients(BATCH_SIZE),
        autoSend: true,
      });

      const start = Date.now();

      await waitFor(
        async () => {
          const batch = await db.query.batches.findFirst({
            where: eq(batches.id, batchId),
          });
          return batch?.status === "completed" ? batch : null;
        },
        { timeout: calculateTestTimeout(BATCH_SIZE, EXPECTED_RATE) }
      );

      const elapsed = Date.now() - start;
      const result = await verifyRateLimit(BATCH_SIZE, elapsed, EXPECTED_RATE);

      logRateLimitResults("Enterprise Scale (500/sec)", BATCH_SIZE, elapsed, EXPECTED_RATE);

      expect(result.withinTolerance).toBe(true);
    },
    { timeout: 300000 }
  );

  it(
    "should handle slow provider (1/sec) gracefully",
    async () => {
      RateLimitScenarios.SLOW_PROVIDER();

      const BATCH_SIZE = 10; // Keep small for slow test
      const EXPECTED_RATE = 1;

      console.log(`\nTesting slow provider (1/sec) with ${BATCH_SIZE} emails`);

      const { id: batchId } = await createBatch({
        name: "Rate Limit Test - Slow Provider",
        subject: "Test",
        fromEmail: "test@batchsender.local",
        recipients: generateRecipients(BATCH_SIZE),
        autoSend: true,
      });

      const start = Date.now();

      await waitFor(
        async () => {
          const batch = await db.query.batches.findFirst({
            where: eq(batches.id, batchId),
          });
          return batch?.status === "completed" ? batch : null;
        },
        { timeout: calculateTestTimeout(BATCH_SIZE, EXPECTED_RATE) }
      );

      const elapsed = Date.now() - start;
      const result = await verifyRateLimit(BATCH_SIZE, elapsed, EXPECTED_RATE);

      logRateLimitResults("Slow Provider (1/sec)", BATCH_SIZE, elapsed, EXPECTED_RATE);

      expect(result.withinTolerance).toBe(true);
      expect(elapsed).toBeGreaterThan(10000); // Should take at least 10 seconds
    },
    { timeout: 300000 }
  );

  it(
    "should process faster with no rate limiting",
    async () => {
      RateLimitScenarios.NO_LIMIT();

      const BATCH_SIZE = 100;

      console.log(`\nTesting with no rate limiting (${BATCH_SIZE} emails)`);

      const { id: batchId } = await createBatch({
        name: "Rate Limit Test - No Limit",
        subject: "Test",
        fromEmail: "test@batchsender.local",
        recipients: generateRecipients(BATCH_SIZE),
        autoSend: true,
      });

      const start = Date.now();

      await waitFor(
        async () => {
          const batch = await db.query.batches.findFirst({
            where: eq(batches.id, batchId),
          });
          return batch?.status === "completed" ? batch : null;
        },
        { timeout: 60000 }
      );

      const elapsed = Date.now() - start;
      const actualRate = (BATCH_SIZE / elapsed) * 1000;

      console.log(`No rate limiting: ${actualRate.toFixed(2)}/sec (${elapsed}ms total)`);

      // Should be significantly faster than AWS SES 14/sec limit
      // With no rate limiting, expect at least 20/sec (faster than 14/sec)
      expect(actualRate).toBeGreaterThan(20);
    },
    { timeout: 60000 }
  );
});
